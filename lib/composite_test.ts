// lib/composite_test.ts
import { assertEquals } from "jsr:@std/assert@^1.0.0/equals";
import { join, normalize } from "jsr:@std/path@^1.0.0";
import {
  compose,
  type ComposeContext,
  defaultSqliteEmitter,
  type DiscoveredDb,
  type GlobWalker,
  type SqlEmitter,
} from "./composite.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

/**
 * Deterministic test emitter:
 * - stable header/footer
 * - uses default attach emission (so path quoting/relativizing stays real)
 *
 * Note: compose() always returns SQL ending with exactly one trailing "\n".
 * This emitter's footer intentionally returns no extra blank lines beyond what the core
 * assembler will normalize.
 */
const testEmitter: SqlEmitter = {
  header(ctx: ComposeContext<unknown>) {
    const lines: string[] = [];
    lines.push("-- TEST: Auto-generated by compose()");
    lines.push(
      `-- TEST: scope=${ctx.scope}${
        ctx.tenantId ? ` tenantId=${ctx.tenantId}` : ""
      }`,
    );
    lines.push("");

    for (const pragma of ctx.pragmas) lines.push(pragma);
    if (ctx.pragmas.length) lines.push("");

    return lines;
  },
  attach(db: DiscoveredDb<unknown>, ctx: ComposeContext<unknown>) {
    return defaultSqliteEmitter.attach!(
      db as unknown as DiscoveredDb<Any>,
      ctx as unknown as ComposeContext<Any>,
    );
  },
  footer(ctx: ComposeContext<unknown>) {
    const lines: string[] = [];
    if (ctx.extraSql.length) {
      lines.push("");
      lines.push("-- extra SQL (views, etc.)");
      lines.push(...ctx.extraSql);
    }
    // Do not push an extra "" here; the core code ensures a final "\n".
    return lines;
  },
};

function makeMockWalker(paths: readonly string[]): GlobWalker {
  return {
    async *walk(
      _globs: readonly string[],
      _opts?: { readonly cwd?: string; readonly ignore?: readonly string[] },
    ) {
      for (const p of paths) yield p;
    },
  };
}

Deno.test("compose() emits deterministic composite.sql via golden strings", async (t) => {
  const volumeRoot = "/vol";

  await t.step("admin composite: dedupe + sort + relative paths", async () => {
    const baseDir = join(volumeRoot, "embedded", "admin");

    const discovered = [
      normalize(join(baseDir, "db9.sqlite.db")),
      normalize(join(baseDir, "db0.sqlite.db")),
      normalize(join(baseDir, "db0.sqlite.db")),
      normalize(join(baseDir, "db2.sqlite.db")),
    ];

    const result = await compose({
      layout: { volumeRoot },
      scope: "admin",
      walker: makeMockWalker(discovered),
      configure: (_ctx) => ({
        globs: ["db*.sqlite.db"],
        emitter: testEmitter,
        aliasForKey: (stableKey: string) => {
          const file = stableKey.split("/").pop() ?? stableKey;
          return file.replace(/\.sqlite(\.db)?$/i, "").replace(/\.db$/i, "");
        },
      }),
    });

    const golden = [
      "-- TEST: Auto-generated by compose()",
      "-- TEST: scope=admin",
      "",
      "ATTACH DATABASE 'db0.sqlite.db' AS db0;",
      "ATTACH DATABASE 'db2.sqlite.db' AS db2;",
      "ATTACH DATABASE 'db9.sqlite.db' AS db9;",
      "",
    ].join("\n");

    assertEquals(result.sql, golden);
  });

  await t.step(
    "cross-tenant composite: ignores composite files + deterministic aliasing",
    async () => {
      const baseDir = join(volumeRoot, "embedded", "cross-tenant");

      const discovered = [
        normalize(join(baseDir, "db1.sqlite.db")),
        normalize(join(baseDir, "db2.sqlite.db")),
        normalize(join(baseDir, "composite.sql")),
        normalize(join(baseDir, "composite.sqlite.auto.db")),
      ];

      const result = await compose({
        layout: { volumeRoot },
        scope: "cross-tenant",
        walker: makeMockWalker(discovered),
        configure: (_ctx) => ({
          globs: ["**/*.sqlite.db"],
          emitter: testEmitter,
          aliasForKey: (stableKey: string) => {
            const file = stableKey.split("/").pop() ?? stableKey;
            const stem = file.replace(/\.sqlite(\.db)?$/i, "").replace(
              /\.db$/i,
              "",
            );
            return `cross_${stem}`;
          },
        }),
      });

      const golden = [
        "-- TEST: Auto-generated by compose()",
        "-- TEST: scope=cross-tenant",
        "",
        "ATTACH DATABASE 'db1.sqlite.db' AS cross_db1;",
        "ATTACH DATABASE 'db2.sqlite.db' AS cross_db2;",
        "",
      ].join("\n");

      assertEquals(result.sql, golden);
    },
  );

  await t.step(
    "tenant composite: pragmas + extraSql preserved (asProvided) for multi-line view",
    async () => {
      const tenantId = "tenant-123";
      const baseDir = join(volumeRoot, "embedded", "tenant", tenantId);

      const discovered = [
        normalize(join(baseDir, "db4.sqlite.db")),
        normalize(join(baseDir, "db3.sqlite.db")),
      ];

      const result = await compose({
        layout: { volumeRoot },
        scope: "tenant",
        tenantId,
        walker: makeMockWalker(discovered),
        configure: (_ctx) => ({
          globs: ["db*.sqlite.db"],
          emitter: testEmitter,

          // Pragmas: default is "sorted"; keep that behavior and test it.
          pragmas: () => [
            "PRAGMA synchronous = NORMAL;",
            "PRAGMA journal_mode = WAL;",
            "PRAGMA journal_mode = WAL;",
          ],

          // Extra SQL: for a multi-line view definition, we must preserve author order.
          extraSqlOrder: "asProvided",
          extraSql: (dbs) => {
            const unions = dbs.map((d) =>
              `SELECT '${d.alias}' AS source_db, * FROM ${d.alias}.evidence`
            );
            return [
              `CREATE VIEW IF NOT EXISTS all_evidence AS\n${
                unions.join("\nUNION ALL\n")
              };`,
            ];
          },
        }),
      });

      const golden = [
        "-- TEST: Auto-generated by compose()",
        "-- TEST: scope=tenant tenantId=tenant-123",
        "",
        // Pragmas sorted lexicographically by default:
        "PRAGMA journal_mode = WAL;",
        "PRAGMA synchronous = NORMAL;",
        "",
        "ATTACH DATABASE 'db3.sqlite.db' AS db3;",
        "ATTACH DATABASE 'db4.sqlite.db' AS db4;",
        "",
        "-- extra SQL (views, etc.)",
        "CREATE VIEW IF NOT EXISTS all_evidence AS",
        "SELECT 'db3' AS source_db, * FROM db3.evidence",
        "UNION ALL",
        "SELECT 'db4' AS source_db, * FROM db4.evidence;",
        "",
      ].join("\n");

      assertEquals(result.sql, golden);
    },
  );
});
